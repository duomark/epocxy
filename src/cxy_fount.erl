%%%------------------------------------------------------------------------------
%%% @copyright (c) 2015-2016, DuoMark International, Inc.
%%% @author Jay Nelson <jay@duomark.com>
%%% @reference 2015-2016 Development sponsored by TigerText, Inc. [http://tigertext.com/]
%%% @reference The license is based on the template for Modified BSD from
%%%   <a href="http://opensource.org/licenses/BSD-3-Clause">OSI</a>
%%% @doc
%%%   A cxy_fount is a source of pre-allocated pids. The main operation is
%%%   to get a pid() so that it can be used for a one-shot execution before
%%%   being thrown away. This approach is safer than a worker pool and allows
%%%   similar concurrency execution, however there is a partner spawn regulator
%%%   which controls the pace of new process generation.
%%%
%%%   The fount is implemented as a push-down stack of slab allocated lists
%%%   of processes. The initialization parameters define the size of each
%%%   slab and the depth of the reservoir stack. Whenever a slab is empty,
%%%   the regulator is notified to replace it. The hope is that there is never
%%%   a spike that exhausts the supply, but if there is, the caller will
%%%   be able to signal that the server is busy rather than trying to do
%%%   more work than we are capable of doing. By adjusting the regulator's
%%%   pacing algorithm, the application may control the amount of simultaneous
%%%   working occurring with processes generated by a particular fount instance.
%%%
%%%   There is an option to set (or clear) a notifier. The notifier is
%%%   expected to be a live gen_event server which will receive notifications
%%%   whenever a new slab is allocated, or a request for pids cannot be
%%%   serviced (either the caller asked for more than the fount can hold
%%%   or more than the fount currently has available). The gen_event is
%%%   monitored so that if it crashes, it will be removed as a valid
%%%   notifier.
%%%
%%%   If you need to change the slab / depth allocations, just make a new
%%%   fount and call stop/1 on this fount.
%%%
%%%   WARNING: the fount will crash if your Fount_Behaviour:start_pid/1
%%%   callback returns anything other than a pid().
%%% @since 0.9.9
%%% @end
%%%------------------------------------------------------------------------------
-module(cxy_fount).
-author('Jay Nelson <jay@duomark.com>').

-behaviour(gen_fsm).


%%% API
-export([start_link/4,                  % Fount with no name
         start_link/5,                  % Fount with name

         get_pid/1,    get_pids/2,      % Get 1 pid or list of pids
         get_pid/2,    get_pids/3,      % Get 1 pid or list of pids with retry
         task_pid/2,   task_pids/2,     % Send message to pid
         task_pid/3,   task_pids/3,     % Send message to pid with retry

         get_spawn_timing/1,            % Report all allocator timings in microseconds
         get_total_rate_per_slab/1,     % Report the round trip allocator slab rate (micros)
         get_total_rate_per_process/1,  % Report the round trip allocator process rate (micros)
         get_spawn_rate_per_slab/1,     % Report the spawn allocator slab rate (micros)
         get_spawn_rate_per_process/1,  % Report the spawn allocator process rate (micros)

         get_status/1,                  % Get status of Fount
         set_notifier/2                 % Set / remove gen_event notifier
        ]).

%%% Convenient test functions.
-export([stop/1]).

%%% gen_fsm callbacks
-export([init/1, format_status/2, handle_sync_event/4,
         handle_event/3, handle_info/3, code_change/4, terminate/3]).

%%% state functions
-export(['INIT'/2, 'EMPTY'/2, 'FULL'/2, 'LOW'/2]).
-export(['INIT'/3, 'EMPTY'/3, 'FULL'/3, 'LOW'/3]).

%%% cxy_fount behaviour callbacks
-type fount_ref() :: pid() | atom().  % gen_fsm reference
-type notifier()  :: no_notifier | pid().
-export_type([fount_ref/0, notifier/0]).

-type fount_option_pair() :: {notifier,        notifier()}
                           | {slab_size,       pos_integer()}
                           | {reservoir_depth, pos_integer()}
                           | {time_slice,      pos_integer()}.

-type fount_args()    :: list().
-type fount_options() :: [fount_option_pair()].
-export_type([fount_option_pair/0, fount_args/0, fount_options/0]).


%%%===================================================================
%%% Behaviour callback helper functions
%%%
%%%   Call one of these functions from your implementation of
%%%   start_pid/1 to spawn and initialize a worker. The workers
%%%   will be linked to Fount automatically by using these functions.
%%%   Not using these functions can result in process leaks.
%%%===================================================================

-type mod_state() :: any().

-callback init      (any())                    -> mod_state().
-callback start_pid (fount_ref(), mod_state()) -> pid()  | {error, Reason::any()}.
-callback send_msg  (Worker,            any()) -> Worker | {error, Reason::any()}
                                                      when Worker :: pid().

%%% Support functions for spawning workers and sending messages in a behaviour module.
-export([spawn_worker/2, spawn_worker/3, spawn_worker/4, send_msg/2]).

-define(SPAWN(__Fount, __Expr), spawn(fun() -> link(__Fount), __Expr end)).
                                      
spawn_worker(Fount, Function)
  when is_pid  (Fount), is_function(Function, 0);
       is_atom (Fount), is_function(Function, 0) ->
    ?SPAWN(Fount, Function()).

spawn_worker(Fount, Function, Args)
  when is_pid  (Fount), is_function(Function, 1), is_list(Args);
       is_atom (Fount), is_function(Function, 1), is_list(Args) ->
    ?SPAWN(Fount, apply(Function, Args));
spawn_worker(Fount, Module, Fun)
  when is_pid  (Fount), is_atom(Module), is_atom(Fun);
       is_atom (Fount), is_atom(Module), is_atom(Fun) ->
    ?SPAWN(Fount, Module:Fun()).

spawn_worker(Fount, Module, Fun, Args)
  when is_pid  (Fount), is_atom(Module), is_atom(Fun), is_list(Args);
       is_atom (Fount), is_atom(Module), is_atom(Fun), is_list(Args) ->
    ?SPAWN(Fount, apply(Module, Fun, Args)).

send_msg(Worker_Pid, Msg)
  when is_pid(Worker_Pid) ->
    Worker_Pid ! Msg,
    Worker_Pid.


-type state_name()   :: 'INIT' | 'EMPTY' | 'FULL' | 'LOW'.
-type microseconds() :: non_neg_integer().

%%% A slab of pids plus time to spawn them, and roundtrip time from
%%% initial request until they are provided to the gen_fsm API.
-record(timed_slab,
        {
          slab       = []      :: [pid()],              % Remaining pids in slab
          start      = {0,0,0} :: erlang:timestamp(),   % Time of slab fill request
          spawn_time = 0       :: microseconds(),       % Elapsed time to spawn slab
          total_time = 0       :: microseconds()        % Time to message and spawn
        }).
-type timed_slab() :: #timed_slab{}.

-record(cf_state,
        {
          regulator                   :: cxy_regulator:regulator_ref(), % regulator fsm pid()
          behaviour                   :: module(),            % Worker action behaviour module
          behaviour_state             :: any(),               % Fount initialized state
          fount       = #timed_slab{} :: timed_slab(),        % One slab, start, spawn time, entire time
          reservoir   = []            :: [timed_slab()],      % Stack of Depth-1 slabs + times
          fount_count = 0             :: non_neg_integer(),   % Num pids in fount
          num_slabs   = 0             :: non_neg_integer(),   % Num slabs in reservoir
          depth       = 0             :: non_neg_integer(),   % Desired reservoir slabs + 1 for fount
          slab_size                   :: pos_integer(),       % Num pids in a single slab
          notifier                    :: notifier()           % Optional gen_event notifier pid
        }).
-type cf_state() :: #cf_state{}.

default_num_slabs()     ->   5.
default_slab_size()     ->  20.
default_reply_timeout() -> 500.


%%%===================================================================
%%% API
%%%===================================================================

%%% Variant ways of making a fount: with and without a local name, with and without a notifier.
-type fount_sup() :: pid().
-spec start_link(fount_sup(),         module(), fount_args(), fount_options()) -> {ok, fount_ref()}.
-spec start_link(fount_sup(), atom(), module(), fount_args(), fount_options()) -> {ok, fount_ref()}.

-record(parsed_fount_options,
        {
          slab_size = default_slab_size() :: pos_integer(),
          num_slabs = default_num_slabs() :: pos_integer(),
          notifier  = no_notifier         :: notifier()
        }).
          
start_link(Fount_Sup_Pid, Fount_Behaviour, Init_Args, Fount_Options)
  when is_pid(Fount_Sup_Pid), is_atom(Fount_Behaviour),
       is_list(Init_Args),    is_list(Fount_Options) ->
    Fsm_Args = {Fount_Sup_Pid, Fount_Behaviour, Init_Args, parse_options(Fount_Options)},
    gen_fsm:start_link(?MODULE, Fsm_Args, []).

start_link(Fount_Sup_Pid, Fount_Name, Fount_Behaviour, Init_Args, Fount_Options)
  when is_pid(Fount_Sup_Pid), is_atom(Fount_Name), is_atom(Fount_Behaviour),
       is_list(Init_Args),    is_list(Fount_Options) ->
    Fsm_Args = {Fount_Sup_Pid, Fount_Behaviour, Init_Args, parse_options(Fount_Options)},
    gen_fsm:start_link({local, Fount_Name}, ?MODULE, Fsm_Args, []).

parse_options(Fount_Options) ->
    case #parsed_fount_options{
            slab_size = proplists:get_value(slab_size, Fount_Options, default_slab_size()),
            num_slabs = proplists:get_value(num_slabs, Fount_Options, default_num_slabs()),
            notifier  = proplists:get_value(notifier,  Fount_Options, no_notifier)
           } of
        #parsed_fount_options{slab_size=SS}     when SS =< 0   -> {error, {slab_size, SS}};
        #parsed_fount_options{num_slabs=NS}     when NS  < 2   -> {error, {num_slabs, NS}};
        #parsed_fount_options{notifier=N} = PFO when is_pid(N) -> PFO;
        #parsed_fount_options{notifier=no_notifier} = PFO      -> PFO;
        #parsed_fount_options{notifier=Not_Pid}                -> {error, {notifier, Not_Pid}}
    end.


%%% Set or clear a gen_event pid() for notifications of slab replacement.
-spec set_notifier (fount_ref(), no_notifier | pid()) -> ok.
-spec stop         (fount_ref()) -> ok.

set_notifier(Fount, Pid)
  when Pid =:= no_notifier; is_pid(Pid) ->
    gen_fsm:sync_send_all_state_event(Fount, {set_notifier, Pid}).

stop(Fount) ->
    gen_fsm:sync_send_all_state_event(Fount, {stop}).


-type milliseconds() :: non_neg_integer().
-type pid_reply()    :: [pid()] | {error, any()}.
-type option()       :: {retry_fun,      fun()}
                      | {retry_times,    pos_integer()}
                      | {retry_backoff, [milliseconds(), ...]}.

-spec get_pid  (fount_ref())                            -> pid_reply().
-spec get_pid  (fount_ref(), [option()])                -> pid_reply().
-spec get_pids (fount_ref(), pos_integer())             -> pid_reply().
-spec get_pids (fount_ref(), pos_integer(), [option()]) -> pid_reply().

%%% These macro are a bit cryptic, but the redundancy was distracting
%%% and if you take for granted they work, later code is more readable.
-define(RETRY(__Fount, __Fsm_Msg, __Recurse_Fn, __Delay, __Retry_Option, __Retry_Reduction),
        case gen_fsm:sync_send_event(__Fount, __Fsm_Msg, default_reply_timeout()) of
            []     -> receive after __Delay -> resume end,  % Give a chance for spawns
                      __Recurse_Fn(__Fount, [{__Retry_Option, __Retry_Reduction}]);
            Result -> Result
        end).

-define(RETRY(__Fount, __Extra, __Fsm_Msg, __Recurse_Fn, __Delay, __Retry_Option, __Retry_Reduction),
        case gen_fsm:sync_send_event(__Fount, __Fsm_Msg, default_reply_timeout()) of
            []     -> receive after __Delay -> resume end,  % Give a chance for spawns
                      __Recurse_Fn(__Fount, __Extra, [{__Retry_Option, __Retry_Reduction}]);
            Result -> Result
        end).

%%% Immediate reply or failure
get_pid(Fount) ->
    gen_fsm:sync_send_event(Fount, {get_pids, 1}, default_reply_timeout()).

%%% Retry a number of times...
get_pid(_Fount, [{retry_times,     0}]) -> [];
get_pid( Fount, [{retry_times, Times}])
  when is_integer(Times), Times > 0 ->
    ?RETRY(Fount, {get_pids, 1}, get_pid, 5, retry_times, Times-1);

%%% Retry with a list of backoff delays...
get_pid(_Fount, [{retry_backoff,                           []}]) -> [];
get_pid( Fount, [{retry_backoff, [This_Delay | Future_Delays]}])
  when is_integer(This_Delay), This_Delay >= 0 ->
    ?RETRY(Fount, {get_pids, 1}, get_pid, This_Delay, retry_backoff, Future_Delays).

%% %%% Retry with a {Delay_Time, Next_Continuation_Fun} mechanism.
%% get_pid( Fount, [{retry_fun, Retry_Fun}])
%%   when is_function(Retry_Fun, 0) ->
%%     case Retry_Fun() of
%%         retry_failed -> 
%%             ?RETRY(Fount, {get_pids, 1}, get_pid, retry_failed, retry_fun, no_fun);
%%         {Delay, Next_Retry_Fun} when is_function(Next_Retry_Fun, 0) ->
%%             timer:sleep(Delay),
%%             ?RETRY(Fount, {get_pids, 1}, get_pid, Delay, retry_fun, Next_Retry_Fun)
%%     end.


%%% Immediate reply or failure.
get_pids(Fount, Num)
  when is_integer(Num), Num >= 0 ->
    gen_fsm:sync_send_event(Fount, {get_pids, Num}, default_reply_timeout()).

%%% Retry a number of times...
get_pids(_Fount, Num, [{retry_times,     0}])
  when is_integer(Num), Num >= 0 ->
    [];
get_pids( Fount, Num, [{retry_times, Times}])
  when is_integer(Num),   Num   >= 0,
       is_integer(Times), Times >  0 ->
    ?RETRY(Fount, Num, {get_pids, Num}, get_pids, 5, retry_times, Times-1);

%%% Retry with a list of backoff delays...
get_pids(_Fount, Num, [{retry_backoff, []}])
  when is_integer(Num), Num >= 0 ->
    [];
get_pids( Fount, Num, [{retry_backoff, [This_Delay | Future_Delays]}])
  when is_integer(Num),        Num        >= 0,
       is_integer(This_Delay), This_Delay >= 0 ->
    ?RETRY(Fount, Num, {get_pids, Num}, get_pids, This_Delay, retry_backoff, Future_Delays).

%% %%% Retry with a {Delay_Time, Next_Continuation_Fun} mechanism.
%% get_pids( Fount, Num, [{retry_fun, Retry_Fun}])
%%   when is_integer(Num), Num >= 0,
%%        is_function(Retry_Fun, 0) ->
%%     case Retry_Fun() of
%%         retry_failed ->
%%             ?RETRY(Fount, Num, {get_pids, Num}, get_pids, retry_failed, retry_fun, no_fun);
%%         {Delay, Next_Retry_Fun} when is_function(Next_Retry_Fun, 0) ->
%%             timer:sleep(Delay),
%%             ?RETRY(Fount, Num, {get_pids, Num}, get_pids, Delay, retry_fun, Next_Retry_Fun)
%%     end.


-spec task_pid  (fount_ref(),  any())              -> pid_reply().
-spec task_pid  (fount_ref(),  any(),  [option()]) -> pid_reply().
-spec task_pids (fount_ref(), [any()])             -> pid_reply().
-spec task_pids (fount_ref(), [any()], [option()]) -> pid_reply().

%%% Immediate reply or failure
task_pid(Fount, Msg) ->
    gen_fsm:sync_send_event(Fount, {task_pids, [Msg]}, default_reply_timeout()).

%%% Retry a number of times, or with a list of backoff milliseconds.
task_pid(_Fount, _Msg, [{retry_times,     0}]) -> [];
task_pid( Fount,  Msg, [{retry_times, Times}])
  when is_integer(Times), Times > 0 ->
    ?RETRY(Fount, Msg, {task_pids, [Msg]}, task_pid, retry_times, Times-1);

task_pid(_Fount, _Msg, [{retry_backoff,           []}]) -> [];
task_pid( Fount,  Msg, [{retry_backoff, [D | Delays]}])
  when is_integer(D), D >= 0 ->
    ?RETRY(Fount, Msg, {task_pids, [Msg]}, task_pid, retry_backoff, Delays).

%% %%% Retry with a {Delay_Time, Next_Continuation_Fun} mechanism.
%% task_pid( Fount,  Msg, [{retry_fun, Retry_Fun}, {delay, D}])
%%   when is_function(Retry_Fun, 0) ->
%%     timer:sleep(D),
%%     case Retry_Fun() of
%%         retry_failed -> 
%%             ?RETRY(Fount, {task_pids, [Msg]}, task_pid, retry_failed, retry_fun, no_fun);
%%         {Delay, Next_Retry_Fun} when is_function(Next_Retry_Fun, 0) ->
%%             ?RETRY(Fount, {task_pids, [Msg]}, task_pid, Delay, retry_fun, Next_Retry_Fun)
%%     end.


%%% Immediate reply or failure.
task_pids(Fount, Msgs) when is_list(Msgs) ->
    gen_fsm:sync_send_event(Fount, {task_pids, Msgs}, default_reply_timeout()).

%%% Retry a number of times, or with a list of backoff milliseconds.
task_pids(_Fount, _Msgs, [{retry_times,     0}])
  when is_list(_Msgs) ->
    [];
task_pids( Fount,  Msgs, [{retry_times, Times}])
  when is_list(Msgs), is_integer(Times), Times > 0 ->
    ?RETRY(Fount, Msgs, {task_pids, Msgs}, task_pids, retry_times, Times-1);

task_pids(_Fount, _Msgs, [{retry_backoff,           []}])
  when is_list(_Msgs) ->
    [];
task_pids( Fount,  Msgs, [{retry_backoff, [D | Delays]}])
  when is_list(Msgs), is_integer(D), D >= 0 ->
    ?RETRY(Fount, Msgs, {task_pids, Msgs}, task_pids, retry_backoff, Delays).

%% %%% Retry with a {Delay_Time, Next_Continuation_Fun} mechanism.
%% task_pids( Fount,  Msg, [{retry_fun, Retry_Fun}, {delay, D}])
%%   when is_function(Retry_Fun, 0) ->
%%     case Retry_Fun() of
%%         retry_failed -> 
%%             ?RETRY(Fount, {task_pids, [Msg]}, task_pid, retry_failed, retry_fun, no_fun);
%%         {Delay, Next_Retry_Fun} when is_function(Next_Retry_Fun, 0) ->
%%             timer:sleep(D),
%%             ?RETRY(Fount, {task_pids, [Msg]}, task_pid, Delay, retry_fun, Next_Retry_Fun)
%%     end.


-type all_rates()   :: proplists:proplist().
-type status_attr() :: {current_state, atom()}              % FSM State function name
                     | {behaviour,     module()}            % Fount behaviour module
                     | {fount_count,   non_neg_integer()}   % Num pids in top slab
                     | {slab_count,    non_neg_integer()}   % Num of full other slabs
                     | {slab_size,     non_neg_integer()}   % Size of a full slab
                     | {max_slabs,     non_neg_integer()}.  % Max number of slabs including fount

-spec get_spawn_timing           (fount_ref()) -> all_rates().
-spec get_total_rate_per_slab    (fount_ref()) -> microseconds().
-spec get_total_rate_per_process (fount_ref()) -> microseconds().
-spec get_spawn_rate_per_slab    (fount_ref()) -> microseconds().
-spec get_spawn_rate_per_process (fount_ref()) -> microseconds().
-spec get_status (fount_ref()) -> [status_attr(), ...].

get_spawn_timing           (Fount) -> gen_fsm:sync_send_all_state_event(Fount, {get_spawn_timing}).
get_total_rate_per_slab    (Fount) -> gen_fsm:sync_send_all_state_event(Fount, {get_total_rate_per_slab}).
get_total_rate_per_process (Fount) -> gen_fsm:sync_send_all_state_event(Fount, {get_total_rate_per_process}).
get_spawn_rate_per_slab    (Fount) -> gen_fsm:sync_send_all_state_event(Fount, {get_spawn_rate_per_slab}).
get_spawn_rate_per_process (Fount) -> gen_fsm:sync_send_all_state_event(Fount, {get_spawn_rate_per_process}).
get_status                 (Fount) -> gen_fsm:sync_send_all_state_event(Fount, {get_status}).


%%%===================================================================
%%% gen_fsm callbacks
%%%===================================================================

%%%------------------------------------------------------------------------------
%%% Initialize the FSM by tasking the regulator to generate Reservoir_Depth
%%% slabs of processes and starting in the 'EMPTY' state. Initialization
%%% happens in two stages: state construction and entry to the 'INIT' state,
%%% followed by getting the regulator from the fount supervisor and moving
%%% to the 'EMPTY' state. This avoids a deadlock between supervisor init and
%%% asking the supervisor for the regulator child.
%%%------------------------------------------------------------------------------

-spec init({fount_sup(), atom(), list(), #parsed_fount_options{}}) -> {ok, 'INIT', cf_state()} | {error, any()}.

init({Fount_Sup_Pid, Fount_Behaviour, Mod_Init_Args,
      #parsed_fount_options{slab_size=Slab_Size, num_slabs=Num_Slabs, notifier=Notifier}}) ->

    %% Get any behaviour state that cxy_fount needs to send to slab allocators...
    Behaviour_State = try   apply(Fount_Behaviour, init, Mod_Init_Args)
                      catch Class:Error -> {error, {Class, Error}}
                      end,

    case Behaviour_State of
        
        %% Fount_Behaviour:init failed, report it and bail out...
        {error, _Reason} = Result ->
            error_logger:error_msg("Fount_Behaviour ~p failed initialization with args ~p",
                                   [Fount_Behaviour, Mod_Init_Args]),
            Result;

        %% Initialize the internal state with the Module Behaviour's init state.
        Behaviour_State ->
            %% Get the regulator sibling from supervisor after init finishes...
            gen_fsm:send_event(self(), {set_regulator, Fount_Sup_Pid}),

            %% Finish initializing, any newly allocated slabs will appear as events.
            Init_State = #cf_state{
                            behaviour       = Fount_Behaviour,
                            behaviour_state = Behaviour_State,
                            slab_size       = Slab_Size,
                            depth           = Num_Slabs,
                            notifier        = Notifier
                           },
            {ok, 'INIT', Init_State}
    end.


%%% Report summarized internal state to sys:get_status or crash logging.
-spec format_status(normal | terminate, list()) -> proplists:proplist().
format_status(_Reason, [_Dict, State]) ->
    generate_status(State).

generate_status(State_Name, State) ->
    [{current_state, State_Name} | generate_status(State)].

generate_status(#cf_state{depth=Depth, fount_count=FC, regulator=Regulator,
                          behaviour=Behaviour, behaviour_state=Behaviour_State,
                          num_slabs=Num_Slabs, slab_size=Slab_Size, notifier=Notifier}) ->
    Max_Pid_Count     = Depth * Slab_Size,
    Current_Pid_Count = FC + (Num_Slabs * Slab_Size),
    [
     {fount_count,     FC},
     {max_slabs,       Depth},
     {slab_size,       Slab_Size},
     {slab_count,      Num_Slabs},
     {max_pids,        Max_Pid_Count},
     {pid_count,       Current_Pid_Count},
     {behaviour,       Behaviour},
     {behaviour_state, Behaviour_State},
     {regulator,       Regulator},
     {notifier,        Notifier}
    ].

%%% Cast to the cxy_regulator for slab allocation.
allocate_slabs(_Regulator, _Slab_Args,              0) -> done;
allocate_slabs( Regulator,  Slab_Args, Num_Allocators)
  when is_integer(Num_Allocators), Num_Allocators > 0 ->
    gen_fsm:send_event(Regulator, {allocate_slab, Slab_Args}),
    allocate_slabs(Regulator, Slab_Args, Num_Allocators-1).


%%%------------------------------------------------------------------------------
%%% Asynch state functions (triggered by gen_fsm:send_event/2)
%%%------------------------------------------------------------------------------

-type slab()     :: {slab, [pid()], erlang:timestamp(), microseconds()}.
-type fin_init() :: {set_regulator, pid()}.

-spec 'INIT'  (fin_init(), cf_state()) -> {next_state, 'EMPTY'       , cf_state()}.
-spec 'EMPTY' (slab(),     cf_state()) -> {next_state, 'EMPTY'       , cf_state()}.
-spec 'LOW'   (slab(),     cf_state()) -> {next_state, 'FULL' | 'LOW', cf_state()}.
-spec 'FULL'  (slab(),     cf_state()) -> {next_state, 'FULL'        , cf_state()}
                                              | {stop, overfull      , cf_state()}.

%%% When init not done yet, we are waiting for the set_regulator signal to move to the 'EMPTY' state.
'INIT'({set_regulator, Fount_Sup_Pid},
       #cf_state{behaviour=Mod, behaviour_state=Mod_State, slab_size=Slab_Size, depth=Depth} = State) ->

    %% Cast a cxy_regulator request for each slab desired...
    Regulator = cxy_fount_sup:get_regulator(Fount_Sup_Pid),
    done      = replace_slabs(Regulator, Mod, Mod_State, Depth, Slab_Size),

    %% Keep the regulator and move to the 'EMPTY' state.
    New_State = State#cf_state{regulator=Regulator},
    next_state({set_regulator, Regulator}, 'EMPTY', New_State).


%%% When empty or low, add newly allocated slab of pids...
'EMPTY' ({slab,  Pids,  Start_Time,  Elapsed}, #cf_state{} = State) -> add_slab(State, Pids, Start_Time, Elapsed);
'EMPTY' (Event,                                #cf_state{} = State) -> next_state({ignored, Event}, 'EMPTY', State).

'LOW'   ({slab,  Pids,  Start_Time,  Elapsed}, #cf_state{} = State) -> add_slab(State, Pids, Start_Time, Elapsed);
'LOW'   (Event,                                #cf_state{} = State) -> next_state({ignored, Event}, 'LOW',   State).

%%% When full, we shouldn't receive a request to add more.
'FULL'  ({slab, _Pids, _Start_Time, _Elapsed}, #cf_state{} = State) -> {stop, overfull, State};
'FULL'  (Event,                                #cf_state{} = State) -> next_state({ignored, Event}, 'FULL',  State).


%%% Then to the reservoir of untapped slabs.
add_slab(#cf_state{slab_size=Slab_Size} = State, Pids, Start_Time, Elapsed) ->

    %% Slabs are added to the fount first if empty, otherwise to the reservoir.
    Total_Time = timer:now_diff(os:timestamp(), Start_Time),
    Timed_Slab = #timed_slab{slab=Pids, start=Start_Time, spawn_time=Elapsed, total_time=Total_Time},
    #cf_state{fount_count=Fount_Count, reservoir=Slabs, depth=Depth, num_slabs=Num_Slabs} = State,
    New_State = case Fount_Count of
                    0              -> State#cf_state{fount=Timed_Slab, fount_count=Slab_Size};
                    FC when FC > 0 -> State#cf_state{reservoir=[Timed_Slab | Slabs], num_slabs=Num_Slabs+1}
                end,

    %% Next FSM state is 'FULL' only when reservoir + fount = Depth.
    #cf_state{num_slabs=New_Num_Slabs} = New_State,
    New_State_Name = case Depth-1 of    % Reservoir is full, without fount.
                         New_Num_Slabs            -> 'FULL';
                         N when N > New_Num_Slabs -> 'LOW'
                         %% Crash if New_Num_Slabs >= Depth, too many slabs created
                     end,
    next_state({slab_added, Slab_Size, Start_Time, Elapsed, Total_Time}, New_State_Name, New_State).


%%%------------------------------------------------------------------------------
%%% Synchronous state functions (triggered by gen_fsm:sync_send_event/2,3)
%%%------------------------------------------------------------------------------

-type from()          :: {pid(), reference()}.
-type synch_request() :: {task_pids, [any()]} | {get_pids, pos_integer()}.

-spec 'INIT'  (any(),           from(), cf_state()) -> {stop,  {unexpected, any()}              , cf_state()}.
-spec 'EMPTY' (synch_request(), from(), cf_state()) -> {reply,      [], 'EMPTY'                 , cf_state()}.
-spec 'FULL'  (synch_request(), from(), cf_state()) -> {reply, [pid()], 'EMPTY' | 'LOW' | 'FULL', cf_state()}.
-spec 'LOW'   (synch_request(), from(), cf_state()) -> {reply, [pid()], 'EMPTY' | 'LOW'         , cf_state()}.

%%% 'INIT'  state never expects any synchronous requests.
'INIT'  (Unexpected_Event,         _From, #cf_state{} = State) -> stop(Unexpected_Event, State).
     
%%% 'EMPTY' state is only exited when a slab of pids is delivered...
'EMPTY' ({task_pids, _Msgs} = Req, _From, #cf_state{} = State) -> reply({empty_reply, Req}, 'EMPTY', State);
'EMPTY' ({get_pids,  _Num}  = Req, _From, #cf_state{} = State) -> reply({empty_reply, Req}, 'EMPTY', State);
'EMPTY' (Event,                    _From, #cf_state{} = State) -> reply({ignored,   Event}, 'EMPTY', State).

%%% 'FULL' state is exited when the fount becomes empty and one more pid is needed...
'FULL'  ({task_pids, Msgs},  _From, #cf_state{} = State) -> reply_task (Msgs,        'FULL',  State);
'FULL'  ({get_pids,  Num},   _From, #cf_state{} = State) -> reply_pids (Num,         'FULL',  State);
'FULL'  (Event,              _From, #cf_state{} = State) -> reply({ignored, Event},  'FULL',  State).

%%% 'LOW' state is exited when there are no reserve slabs or reserve is full.
'LOW'   ({task_pids, Msgs},  _From, #cf_state{} = State) -> reply_task (Msgs,        'LOW',   State);
'LOW'   ({get_pids,  Num},   _From, #cf_state{} = State) -> reply_pids (Num,         'LOW',   State);
'LOW'   (Event,              _From, #cf_state{} = State) -> reply({ignored, Event},  'LOW',   State).


%%%------------------------------------------------------------------------------
%%% reply_task uses reply_pids, then sends messages to them
%%%------------------------------------------------------------------------------

%%% Get as many workers as there are messages to send, then give a message
%%% to each one without traversing the worker or message list more than once.
reply_task(Msgs, State_Fn, #cf_state{behaviour=Module} = State)
  when is_list(Msgs) ->
    %% Well, ok, twice for the message list...
    Num_Pids = length(Msgs),

    %% Notification of empty reply has already been sent if needed.
    Reply = {reply, Workers, _New_State_Name, _New_State}
        = reply_pids(Num_Pids, State_Fn, State),

    %% Message workers only after they have been unlinked.
    _ = [all_sent = msg_workers(Module, Workers, Msgs) || Workers =/= []],
    Reply.

msg_workers(_Module,                 [],           []) -> all_sent;
msg_workers( Module, [Worker | Workers], [Msg | Msgs]) ->
    _ = send_msg (Module, Worker,  Msg),
    msg_workers  (Module, Workers, Msgs).

send_msg(Module, Pid, Msg) ->
    try   Module:send_msg(Pid, Msg) of
          Pid when is_pid(Pid) -> Pid;
          {error, Reason} ->
            error_logger:error_msg("~p:send_msg(~p, ~p) reported ~p => ~9999p~n",
                                   [Module, Pid, Msg, Reason, erlang:get_stacktrace()])
    catch
        Class:Type ->
            Error_Msg = {error, {Module, send_msg, Class, Type, Msg}},
            error_logger:error_msg("~p:send_msg(~p, ~p) crashed with ~p => ~9999p~n",
                                   [Module, Pid, Msg, Error_Msg, erlang:get_stacktrace()])
    end.


%%%------------------------------------------------------------------------------
%%% reply_pids responds with the desired worker list of pid()
%%%------------------------------------------------------------------------------

%% 0 Pids wanted...
reply_pids (0,  State_Fn, #cf_state{} = State) ->
    reply({empty_reply, {get_pids, 0}}, State_Fn, State);
 
%% 1 Pid wanted...
reply_pids (1, _State_Fn, #cf_state{fount=#timed_slab{slab=[Pid]}} = State) ->
    replace_slab_then_return_fount([Pid], State);
reply_pids (1,  State_Fn, #cf_state{fount=#timed_slab{slab=[Pid | More]}, fount_count=FC} = State) ->
    New_State = State#cf_state{fount=#timed_slab{slab=More}, fount_count=FC-1},
    reply([Pid], State_Fn, New_State);
reply_pids (1, _State_Fn, #cf_state{fount=#timed_slab{slab=[]}, num_slabs=Num_Slabs, slab_size=Slab_Size} = State) ->
    [#timed_slab{slab=[Pid | Rest]} = Slab | More_Slabs] = State#cf_state.reservoir,
    New_Fount = Slab#timed_slab{slab=Rest},
    New_State = State#cf_state{fount=New_Fount, reservoir=More_Slabs, fount_count=Slab_Size-1, num_slabs=Num_Slabs-1},
    reply([Pid], 'LOW', New_State);

%%% More than 1 pid wanted, can be supplied by Fount...
%%% (Fount might be greater than slab_size, so this clause comes before slab checks)
reply_pids (Num_Pids, _State_Fn, #cf_state{fount=#timed_slab{slab=Fount}, fount_count=FC} = State)
  when Num_Pids =:= FC ->
    replace_slab_then_return_fount(Fount, State);

reply_pids (Num_Pids,  State_Fn, #cf_state{fount=#timed_slab{slab=Fount}, fount_count=FC} = State)
  when Num_Pids < FC ->
    Fount_Count = FC - Num_Pids,
    {Pids, Remaining} = lists:split(Num_Pids, Fount),
    New_Fount = #timed_slab{slab=Remaining},
    reply(Pids, State_Fn, State#cf_state{fount=New_Fount, fount_count=Fount_Count});

%%% More than 1 pid wanted, matches Slab_Size, grab the top of the reservoir if it's not empty...
reply_pids (Num_Pids, _State_Fn, #cf_state{slab_size=Slab_Size, num_slabs=Num_Slabs} = State)
  when Num_Pids =:= Slab_Size, Num_Slabs > 0 ->
    #cf_state{behaviour=Mod, behaviour_state=Mod_State, reservoir=[#timed_slab{slab=Slab} | More_Slabs]} = State,
    done = replace_slabs(State#cf_state.regulator, Mod, Mod_State, 1, Slab_Size),
    reply(Slab, 'LOW', State#cf_state{reservoir=More_Slabs, num_slabs=Num_Slabs-1});

%%% More than 1 pid wanted, less than Slab_Size, grab the front of top slab, add balance to fount...
reply_pids (Num_Pids, _State_Fn, #cf_state{slab_size=Slab_Size, num_slabs=Num_Slabs} = State)
  when Num_Pids < Slab_Size, Num_Slabs > 0 ->
    #cf_state{behaviour=Mod, behaviour_state=Mod_State, fount=#timed_slab{slab=Fount}, fount_count=FC,
              reservoir=[#timed_slab{slab=Slab} = Reservoir_Slab | More_Slabs]} = State,
    done = replace_slabs(State#cf_state.regulator, Mod, Mod_State, 1, Slab_Size),
    {Pids, Remaining} = lists:split(Num_Pids, Slab),
    Partial_Slab_Size = Slab_Size - Num_Pids,
    Fount_Count = FC + Partial_Slab_Size,

    %% Try to be efficient about reconstructing Fount (may end up larger than a slab)...
    %% The timing will be off, because we reflect the time to spawn Remaining.
    New_Fount = case Partial_Slab_Size > FC of
                    true  -> Reservoir_Slab#timed_slab{slab=Fount ++ Remaining};
                    false -> Reservoir_Slab#timed_slab{slab=Remaining ++ Fount}
                end,
    New_State = State#cf_state{fount=New_Fount, fount_count=Fount_Count,
                               reservoir=More_Slabs, num_slabs=Num_Slabs-1},
    reply(Pids, 'LOW', New_State);

%%% More than 1 Pid wanted, but not enough available...
reply_pids (Num_Pids,  State_Fn, #cf_state{fount_count=FC, slab_size=Slab_Size, num_slabs=Num_Slabs} = State)
  when Num_Pids > (Num_Slabs * Slab_Size) + FC ->
    reply({empty_reply, {get_pids, Num_Pids}}, State_Fn, State);

%%% More than 1 pid wanted, more than Slab_Size, see if there are enough to return...
reply_pids (Num_Pids, _State_Fn, #cf_state{fount_count=FC, slab_size=Slab_Size, num_slabs=Num_Slabs} = State)
  when Num_Pids > Slab_Size, Num_Pids < (Num_Slabs * Slab_Size) + FC ->
    Excess       = Num_Pids rem Slab_Size,
    Slabs_Needed = Num_Pids div Slab_Size,
    #cf_state{behaviour=Mod, behaviour_state=Mod_State, fount=Fount_Slab,
              reservoir=[#timed_slab{slab=First_Slab} | More_Slabs] = All_Slabs} = State,
    #timed_slab{slab=Fount} = Fount_Slab,
    done = replace_slabs(State#cf_state.regulator, Mod, Mod_State, Slabs_Needed, Slab_Size),

    %% Append the slabs and the excess into a single list...
    Full_Slabs_Left = Num_Slabs - Slabs_Needed,
    {{Pids, Remaining_Fount_Pids}, {Slabs_Requested, Remaining_Slabs}, {New_Num_Slabs, New_Fount_Count}}
        = case FC of

              %% Slabs_Needed is more than is available (so Fount must have more than 1 slab in it)...
              _Enough when Full_Slabs_Left < 0 ->
                  Slab_Pids          = Num_Pids - FC,
                  Final_Slabs_Needed = Slab_Pids div Slab_Size,
                  Final_Excess       = Slab_Pids rem Slab_Size,
                  Final_Slabs_Left   = Num_Slabs - Final_Slabs_Needed,
                  case Final_Excess of
                      0 when Final_Slabs_Left > 0 ->   % Should never be < 0 (= 0 is covered by all pids used up)
                          done = replace_slabs(State#cf_state.regulator, Mod, Mod_State, 1, Slab_Size), % Fount empty, replace.
                          {{Fount, []}, lists:split(Final_Slabs_Needed, All_Slabs), {Final_Slabs_Left, 0}};
                      FE ->   % All of the Fount + Final_Excess taken from first slab
                          {lists:split(FC + Final_Excess, Fount ++ First_Slab), lists:split(Final_Slabs_Needed-1, More_Slabs), {Final_Slabs_Left, Slab_Size-FE}}
                  end;

              %% Take N slabs (no more than present) + Excess from Fount when Fount is bigger than Excess...
              Enough when Enough > Excess, Excess > 0 ->   % Full_Slabs_Left >= 0
                  {lists:split(Excess, Fount), lists:split(Slabs_Needed, All_Slabs), {Full_Slabs_Left, FC-Excess}};

              %% Take N slabs + Excess from Fount when Excess is exactly Fount size...
              Excess when Excess > 0 ->
                  done = replace_slabs(State#cf_state.regulator, Mod, Mod_State, 1, Slab_Size), % Fount empty, replace.
                  {{Fount, []}, lists:split(Slabs_Needed, All_Slabs), {Full_Slabs_Left, 0}};

              %% Take N slabs when no Excess...
              FC when Excess =:= 0 ->
                  {{[], Fount}, lists:split(Slabs_Needed, All_Slabs), {Full_Slabs_Left, FC}};

              %% Excess is bigger than Fount.
              _Not_Enough when Excess > FC ->
                  done = replace_slabs(State#cf_state.regulator, Mod, Mod_State, 1, Slab_Size), % Replace extra slab needed.
                  {lists:split(Excess, Fount ++ First_Slab), lists:split(Slabs_Needed, More_Slabs), {Full_Slabs_Left-1, FC+Slab_Size-Excess}}
          end,
    Remaining_Fount = Fount_Slab#timed_slab{slab=Remaining_Fount_Pids},
    Pids_Requested = lists:append([Pids | [S || #timed_slab{slab=S} <- Slabs_Requested]]),
    New_State_Fn = case Remaining_Fount#timed_slab.slab =:= [] andalso Remaining_Slabs =:= [] of true -> 'EMPTY'; false -> 'LOW' end,
    New_State = State#cf_state{fount=Remaining_Fount, fount_count=New_Fount_Count, reservoir=Remaining_Slabs, num_slabs=New_Num_Slabs},
    case Pids of
        []   -> reply({empty_reply, {get_pids, Num_Pids}}, New_State_Fn, New_State);
        Pids -> reply(Pids_Requested, New_State_Fn, New_State)
    end;

%%% All the pids wanted, change to the EMPTY state.
reply_pids (Num_Pids, _State_Fn, #cf_state{fount=#timed_slab{slab=Fount}, fount_count=FC, slab_size=Slab_Size, num_slabs=Num_Slabs} = State)
  when Num_Pids =:= (Num_Slabs * Slab_Size) + FC ->
    #cf_state{behaviour=Mod, behaviour_state=Mod_State, reservoir=Reservoir} = State, 
    done = replace_slabs(State#cf_state.regulator, Mod, Mod_State, Num_Slabs + 1, Slab_Size),
    Pids_Requested = lists:append([Fount | [S || #timed_slab{slab=S} <- Reservoir]]),
    reply(Pids_Requested, 'EMPTY', State#cf_state{fount=#timed_slab{}, reservoir=[], fount_count=0, num_slabs=0}).

replace_slabs(Regulator, Mod, Mod_State, Num_Slabs, Slab_Size) ->
    Slab_Allocator_Args = {self(), Mod, Mod_State, os:timestamp(), Slab_Size},
    done = allocate_slabs(Regulator, Slab_Allocator_Args, Num_Slabs).

replace_slab_then_return_fount(Pids, #cf_state{behaviour=Mod, behaviour_state=Mod_State, slab_size=Slab_Size, num_slabs=Num_Slabs} = State) ->
    done = replace_slabs(State#cf_state.regulator, Mod, Mod_State, 1, Slab_Size),
    New_State = State#cf_state{fount=#timed_slab{slab=[]}, fount_count=0},
    case Num_Slabs of
        0 -> reply(Pids, 'EMPTY', New_State);
        _ -> reply(Pids, 'LOW',   New_State)
    end.

%%% Notify, then terminate when stop events are triggered.
stop(Event, #cf_state{notifier=Notifier} = State) ->
    _ = [gen_event:notify(Notifier, {?MODULE, self(), {bad_synch_msg,  Event}}) || Notifier =/= no_notifier],
    {stop, {unexpected, Event}, State}.

%%% Notify when unexpected asynch events happen...
next_state({set_regulator, _Regulator} = Event, New_State_Fn, #cf_state{notifier=Notifier} = New_State_Record) ->
    _ = [gen_event:notify(Notifier, {?MODULE, self(), Event}) || Notifier =/= no_notifier],
    {next_state, New_State_Fn, New_State_Record};
next_state({ignored, Event}, New_State_Fn, #cf_state{notifier=Notifier} = New_State_Record) ->
    _ = [gen_event:notify(Notifier, {?MODULE, self(), {bad_asynch_msg, Event}}) || Notifier =/= no_notifier],
    {next_state, New_State_Fn, New_State_Record};
%%% Notify when a slab is added to the internal fount state.
next_state({slab_added, _,_,_,_} = Add_Slab_Msg, New_State_Fn, #cf_state{notifier=Notifier} = New_State_Record) ->
    _ = [gen_event:notify(Notifier, {?MODULE, self(), Add_Slab_Msg}) || Notifier =/= no_notifier],
    {next_state, New_State_Fn, New_State_Record}.


%%% Notify when unexpected synch events happen...
reply({ignored, Cmd}, New_State_Fn, #cf_state{notifier=Notifier} = New_State_Record) ->
    _ = [gen_event:notify(Notifier, {?MODULE, self(), {bad_synch_msg, Cmd}}) || Notifier =/= no_notifier],
    {reply, ignored, New_State_Fn, New_State_Record};

%%% Notify when request for pids cannot be serviced...
reply({empty_reply, _Request} = Empty, New_State_Fn, #cf_state{notifier=Notifier} = New_State_Record) ->
    _ = [gen_event:notify(Notifier, {?MODULE, self(), Empty}) || Notifier =/= no_notifier],
    {reply, [], New_State_Fn, New_State_Record};

%%% Successful replies don't require any notifications.
%%% Unlink the reply pids so they can no longer take down the cxy_fount.
reply(Pids, New_State_Fn, #cf_state{} = New_State_Record) ->
    _ = [unlink(Pid) || Pid <- Pids],
    {reply, Pids, New_State_Fn, New_State_Record}.


%%%------------------------------------------------------------------------------
%%% Synchronous state functions (trigger gen_fsm:sync_send_all_state_event/2)
%%%------------------------------------------------------------------------------

-type rate()     :: pos_integer().
-type status()   :: proplists:proplist().

-spec handle_sync_event ({get_spawn_timing},             from(), State_Name, State)
         -> {reply, all_rates(), State_Name, State} when State_Name :: state_name(), State :: cf_state();
                        ({get_spawn_rate_per_slab},      from(), State_Name, State)
         -> {reply, rate(),      State_Name, State} when State_Name :: state_name(), State :: cf_state();
                        ({get_spawn_rate_per_process},   from(), State_Name, State)
         -> {reply, rate(),      State_Name, State} when State_Name :: state_name(), State :: cf_state();
                        ({get_status},                   from(), State_Name, State)
         -> {reply, status(),    State_Name, State} when State_Name :: state_name(), State :: cf_state();
                        ({set_notifier_pid, notifier()}, from(), State_Name, State)
         -> {reply, status(),    State_Name, State} when State_Name :: state_name(), State :: cf_state().

get_slab_times(Fount, Fount_Time, Num_Slabs, Slab_Times) ->
    case Fount of
        [] -> {Slab_Times,                Num_Slabs};
        _  -> {[Fount_Time | Slab_Times], Num_Slabs+1}
    end.

compute_two_decimals(    0, _Times) -> 0;
compute_two_decimals(Denom,  Times) -> (lists:sum(Times) * 100 div Denom) / 100.

total_rate_per_slab(#cf_state{fount=#timed_slab{slab=Fount, total_time=Total_Time}, reservoir=Slabs, num_slabs=Num_Slabs}) ->
    Slab_Times = [Slab_Total_Time || #timed_slab{total_time=Slab_Total_Time} <- Slabs],
    {Times, Slab_Count} = get_slab_times(Fount, Total_Time, Num_Slabs, Slab_Times),
    compute_two_decimals(Slab_Count, Times).

total_rate_per_process(#cf_state{fount=#timed_slab{slab=Fount, total_time=Total_Time}, reservoir=Slabs,
                                 fount_count=FC, num_slabs=Num_Slabs, slab_size=Slab_Size}) ->
    Slab_Times = [Slab_Total_Time || #timed_slab{total_time=Slab_Total_Time} <- Slabs],
    {Times, Slab_Count} = get_slab_times(Fount, Total_Time, Num_Slabs, Slab_Times),
    Num_Processes = FC + (Slab_Count*Slab_Size),
    compute_two_decimals(Num_Processes, Times).

spawn_rate_per_slab(#cf_state{fount=#timed_slab{slab=Fount, spawn_time=Fount_Time}, reservoir=Slabs, num_slabs=Num_Slabs}) ->
    Slab_Times = [Slab_Time || #timed_slab{spawn_time=Slab_Time} <- Slabs],
    {Times, Slab_Count} = get_slab_times(Fount, Fount_Time, Num_Slabs, Slab_Times),
    compute_two_decimals(Slab_Count, Times).

spawn_rate_per_process(#cf_state{fount=#timed_slab{slab=Fount, spawn_time=Fount_Time}, reservoir=Slabs,
                                 fount_count=FC, num_slabs=Num_Slabs, slab_size=Slab_Size}) ->
    Slab_Times = [Slab_Time || #timed_slab{spawn_time=Slab_Time} <- Slabs],
    {Times, Slab_Count} = get_slab_times(Fount, Fount_Time, Num_Slabs, Slab_Times),
    Num_Processes = FC + (Slab_Count*Slab_Size),
    compute_two_decimals(Num_Processes, Times).


handle_sync_event ({get_spawn_timing}, _From, State_Name, State) ->
    Results = [{total_rate_per_slab,    total_rate_per_slab    (State)},
               {total_rate_per_process, total_rate_per_process (State)},
               {spawn_rate_per_slab,    spawn_rate_per_slab    (State)},
               {spawn_rate_per_process, spawn_rate_per_process (State)}],
    {reply, Results, State_Name, State};

handle_sync_event ({get_total_rate_per_slab},    _From, State_Name, State) -> {reply, total_rate_per_slab        (State), State_Name, State};
handle_sync_event ({get_total_rate_per_process}, _From, State_Name, State) -> {reply, total_rate_per_process     (State), State_Name, State};
handle_sync_event ({get_spawn_rate_per_slab},    _From, State_Name, State) -> {reply, spawn_rate_per_slab        (State), State_Name, State};
handle_sync_event ({get_spawn_rate_per_process}, _From, State_Name, State) -> {reply, spawn_rate_per_process     (State), State_Name, State};
handle_sync_event ({get_status},                 _From, State_Name, State) -> {reply, generate_status(State_Name, State), State_Name, State};

handle_sync_event ({set_notifier, Pid}, _From, State_Name, #cf_state{} = State)
  when Pid =:= no_notifier; is_pid(Pid) ->
    {reply, ok, State_Name, State#cf_state{notifier=Pid}};
     
handle_sync_event ({stop},  From, _State_Name, #cf_state{} = State) -> {stop, normal,   stop_workers(From, State), State};
handle_sync_event (_Event, _From,  State_Name, #cf_state{} = State) -> {reply, ignored, State_Name,                State}.

stop_workers(From, #cf_state{notifier=Notifier} = State) ->
    _ = [gen_event:notify(Notifier, {?MODULE, self(), {stop_requested, From}}) || Notifier =/= no_notifier],
    #cf_state{fount=#timed_slab{slab=Fount}, reservoir=Raw_Slabs} = State,
    Slabs = [Slab || #timed_slab{slab=Slab} <- Raw_Slabs],
    _ = [ [stop_worker(Pid) || Pid <- Slab] || Slab <- [Fount | Slabs] ],
    ok.

stop_worker(Pid) -> unlink(Pid), exit(Pid, kill).
    

%%%===================================================================
%%% Unused functions
%%%===================================================================

-spec handle_event (any(), State_Name, State)
        -> {next_state, State_Name, State} when State_Name :: state_name(), State :: cf_state().
-spec handle_info  (any(), State_Name, State)
        -> {next_state, State_Name, State} when State_Name :: state_name(), State :: cf_state().
-spec code_change  (any(), State_Name, State, any())
        -> {ok,         State_Name, State} when State_Name :: state_name(), State :: cf_state().

handle_event (_Event,   State_Name,  State) -> {next_state, State_Name, State}.
handle_info  (_Info,    State_Name,  State) -> {next_state, State_Name, State}.
code_change  (_OldVsn,  State_Name,  State, _Extra) -> {ok, State_Name, State}.

%%% Pre-spawned pids are linked and die when FSM dies.
-spec terminate(atom(), state_name(), cf_state()) -> ok.
terminate(_Reason, _State_Name,  _State) -> ok.
